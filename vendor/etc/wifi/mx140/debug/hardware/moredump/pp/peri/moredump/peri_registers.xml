<?xml version="1.0" encoding="utf-8"?>

<!--
(c) SCSC 2015-2016 autogenerated by moredump.py as part of 'drun prep'.
  Changes made to this file may cause incorrect behaviour and will be lost if it is regenerated.

  XML file defining registers for peri subsystem moredump
  Chip hash: 5266


-->

<subsystem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.samsung.com ../Registers.xsd"
  name="peri">
  <block name="pcr_config" comment="WLAN Processor platform configuration - ">
    <register addr="d0000000" rw_flags="R" width="4" name="PCR_VERSION" comment="Connected to CHIP_VERSION_ID from the pmu_remap register block."/>
    <register addr="d0000004" rw_flags="R" width="2" name="PCR_PERI_REGISTER_HASH" comment="Contains a 32bit hash of all the PERI register tree source used in the IP"/>
    <register addr="d0000008" rw_flags="RW" width="4" name="PCR_PIO_OWNER" comment="Specify which UCPU owns the PIOs being access."/>
    <register addr="d000000c" rw_flags="RW" width="2" name="PCR_WL_ADC_COMMON_CFG[0]" comment=" "/>
    <register addr="d0000010" rw_flags="RW" width="4" name="PCR_WL_ADC_CFG[0]" comment=""/>
    <register addr="d0000014" rw_flags="RW" width="4" name="PCR_WL_ADC_CFG[1]" comment=""/>
    <register addr="d0000018" rw_flags="RW" width="1" name="PCR_WL_ADC_CFG1[0]" comment=""/>
    <register addr="d000001c" rw_flags="RW" width="1" name="PCR_WL_ADC_CFG1[1]" comment=""/>
    <register addr="d0000020" rw_flags="RW" width="4" name="PCR_WL_ADC_CTRLI[0]" comment=""/>
    <register addr="d0000024" rw_flags="RW" width="4" name="PCR_WL_ADC_CTRLI[1]" comment=""/>
    <register addr="d0000028" rw_flags="RW" width="4" name="PCR_WL_ADC_CTRLQ[0]" comment=""/>
    <register addr="d000002c" rw_flags="RW" width="4" name="PCR_WL_ADC_CTRLQ[1]" comment=""/>
    <register addr="d0000030" rw_flags="RW" width="1" name="PCR_WL_DAC_COMMON_CFG[0]" comment=" "/>
    <register addr="d0000034" rw_flags="RW" width="1" name="PCR_WL_DAC_COMMON_CFG[1]" comment=" "/>
    <register addr="d0000038" rw_flags="RW" width="2" name="PCR_WL_DAC_CFG[0]" comment=""/>
    <register addr="d000003c" rw_flags="RW" width="2" name="PCR_WL_DAC_CFG[1]" comment=""/>
    <register addr="d0000040" rw_flags="RW" width="2" name="PCR_WL_DAC_CTR_CM[0]" comment="Bit [23] is OR'd with WL_RADIO_TX_DAC_EN, so don't set [23] to 1 in this register unless you want to force it on."/>
    <register addr="d0000044" rw_flags="RW" width="2" name="PCR_WL_DAC_CTR_CM[1]" comment="Bit [23] is OR'd with WL_RADIO_TX_DAC_EN, so don't set [23] to 1 in this register unless you want to force it on."/>
    <register addr="d0000048" rw_flags="RW" width="4" name="PCR_WL_DAC_CTRLI[0]" comment=""/>
    <register addr="d000004c" rw_flags="RW" width="4" name="PCR_WL_DAC_CTRLI[1]" comment=""/>
    <register addr="d0000050" rw_flags="RW" width="4" name="PCR_WL_DAC_CTRLQ[0]" comment=""/>
    <register addr="d0000054" rw_flags="RW" width="4" name="PCR_WL_DAC_CTRLQ[1]" comment=""/>
    <register addr="d0000058" rw_flags="RW" width="1" name="PCR_WL_DAC_MSB_CTRLI[0]" comment="Most Significant Bits on the DAC I control bus. Bit 35:32"/>
    <register addr="d000005c" rw_flags="RW" width="1" name="PCR_WL_DAC_MSB_CTRLI[1]" comment="Most Significant Bits on the DAC I control bus. Bit 35:32"/>
    <register addr="d0000060" rw_flags="RW" width="1" name="PCR_WL_DAC_MSB_CTRLQ[0]" comment="Most Significant Bits on the DAC Q control bus. Bit 35:32"/>
    <register addr="d0000064" rw_flags="RW" width="1" name="PCR_WL_DAC_MSB_CTRLQ[1]" comment="Most Significant Bits on the DAC Q control bus. Bit 35:32"/>
    <register addr="d0000068" rw_flags="RW" width="1" name="WLAN_ABB_DAC_INVERT_EN[0]" comment="Set to 1 to invert the DAC clock (index = DAC ID). This is expected to be required if the DAC and Timestamping clocks are deemed to be in a metastable phase."/>
    <register addr="d000006c" rw_flags="RW" width="1" name="WLAN_ABB_DAC_INVERT_EN[1]" comment="Set to 1 to invert the DAC clock (index = DAC ID). This is expected to be required if the DAC and Timestamping clocks are deemed to be in a metastable phase."/>
    <register addr="d0000070" rw_flags="RW" width="1" name="WLAN_ABB_ADC_INVERT_EN[0]" comment="Set to 1 to invert the ADC clock (index = ADC ID). This is expected to be required if the ADC and Timestamping clocks are deemed to be in a metastable phase."/>
    <register addr="d0000074" rw_flags="RW" width="1" name="WLAN_ABB_ADC_INVERT_EN[1]" comment="Set to 1 to invert the ADC clock (index = ADC ID). This is expected to be required if the ADC and Timestamping clocks are deemed to be in a metastable phase."/>
    <register addr="d0000078" rw_flags="RW" width="1" name="WLAN_ABB_DEBUG_SEL" comment="WLAN ADC/DAC interface debug selection"/>
    <register addr="d000007c" rw_flags="R" width="2" name="WLAN_ABB_DEBUG_STATUS" comment="Value of DEBUG_OUT on WLAN_ABB"/>
    <register addr="d0000080" rw_flags="RW" width="1" name="WLAN_ABB_DAC_PHY_PORT_SEL[0]" comment="Select which PHY PORT is connected to a DAC (if any). The register index is the DAC ID (see REGDEF_WLAN_ABB_DAC_ID), and the value is the PHY PORT."/>
    <register addr="d0000084" rw_flags="RW" width="1" name="WLAN_ABB_DAC_PHY_PORT_SEL[1]" comment="Select which PHY PORT is connected to a DAC (if any). The register index is the DAC ID (see REGDEF_WLAN_ABB_DAC_ID), and the value is the PHY PORT."/>
    <register addr="d0000088" rw_flags="RW" width="1" name="WLAN_ABB_PHY_LH_DAC_CLK_SEL[0]" comment="Select whether this PHY's DAC (PHY2ABB) LongHop uses the PORT0 (0) or PORT1 (1) DAC clock. The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d000008c" rw_flags="RW" width="1" name="WLAN_ABB_PHY_LH_DAC_CLK_SEL[1]" comment="Select whether this PHY's DAC (PHY2ABB) LongHop uses the PORT0 (0) or PORT1 (1) DAC clock. The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d0000090" rw_flags="RW" width="1" name="WLAN_ABB_PHY_PORT_ADC_SEL[0]" comment="Select which ADC is connected to each PHY PORT (if any). The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d0000094" rw_flags="RW" width="1" name="WLAN_ABB_PHY_PORT_ADC_SEL[1]" comment="Select which ADC is connected to each PHY PORT (if any). The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d0000098" rw_flags="RW" width="1" name="WLAN_ABB_PHY_LH_ADC_CLK_SEL[0]" comment="Select whether this PHY's ADC (ABB2PHY) LongHop uses the PORT0 (0) or PORT1 (1) DAC clock. The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d000009c" rw_flags="RW" width="1" name="WLAN_ABB_PHY_LH_ADC_CLK_SEL[1]" comment="Select whether this PHY's ADC (ABB2PHY) LongHop uses the PORT0 (0) or PORT1 (1) DAC clock. The register index is PHY ID (see REGDEF_WLAN_ABB_PHY_ID)."/>
    <register addr="d00000a0" rw_flags="RW" width="4" name="WLAN_ABB_DAC_DC_OFFSET[0]" comment="DC offset for each DAC"/>
    <register addr="d00000a4" rw_flags="RW" width="4" name="WLAN_ABB_DAC_DC_OFFSET[1]" comment="DC offset for each DAC"/>
    <register addr="d00000a8" rw_flags="RW" width="1" name="WLAN_ABB_TS_CFG" comment="WLAN ABB timestamp configuration."/>
    <register addr="d00000ac" rw_flags="R" width="4" name="WLAN_ABB_TS_DAC_STATUS[0]" comment="The DAC timestamp values. The index is the DAC ID."/>
    <register addr="d00000b0" rw_flags="R" width="4" name="WLAN_ABB_TS_DAC_STATUS[1]" comment="The DAC timestamp values. The index is the DAC ID."/>
    <register addr="d00000b4" rw_flags="R" width="4" name="WLAN_ABB_TS_ADC_STATUS[0]" comment="The ADC timestamp values. The index is the ADC ID."/>
    <register addr="d00000b8" rw_flags="R" width="4" name="WLAN_ABB_TS_ADC_STATUS[1]" comment="The ADC timestamp values. The index is the ADC ID."/>
    <register addr="d00000bc" rw_flags="R" width="1" name="WLAN_ABB_TS_DAC_METASTABILITY_DETECTED" comment="The DAC timestamp values may be inccurate by a +/- 1 clock cycles. Consider toggling WLAN_ABB_DAC_INVERT_EN. The index is the DAC ID."/>
    <register addr="d00000c0" rw_flags="R" width="1" name="WLAN_ABB_TS_ADC_METASTABILITY_DETECTED" comment="The ADC timestamp values may be inccurate by a +/- 1 clock cycles. Consider toggling WLAN_ABB_ADC_INVERT_EN. The index is the ADC ID."/>
    <register addr="d00000c4" rw_flags="W" width="1" name="WLAN_ABB_TS_DAC_METASTABILITY_DETECTED_CLR" comment="Write 1 to clear corresponding WLAN_ABB_TS_DAC_METASTABILITY_DETECTED "/>
    <register addr="d00000c8" rw_flags="W" width="1" name="WLAN_ABB_TS_ADC_METASTABILITY_DETECTED_CLR" comment="Write 1 to clear corresponding WLAN_ABB_TS_ADC_METASTABILITY_DETECTED "/>
    <register addr="d00000cc" rw_flags="RW" width="2" name="WLAN_ABB_LH_PHY2ABB_CONTROL[0][0]" comment="LongHop control for PHY2ABB."/>
    <register addr="d00000d0" rw_flags="R" width="2" name="WLAN_ABB_LH_PHY2ABB_STATUS[0][0]" comment="LongHop status for the PHY2ABB."/>
    <register addr="d00000d4" rw_flags="RW" width="2" name="WLAN_ABB_LH_ABB2PHY_CONTROL[0][0]" comment="LongHop control for ABB2PHY."/>
    <register addr="d00000d8" rw_flags="R" width="2" name="WLAN_ABB_LH_ABB2PHY_STATUS[0][0]" comment="LongHop status for the ABB2PHY."/>
    <register addr="d00000dc" rw_flags="RW" width="1" name="WLAN_ABB_LH_DEBUG_CONTROL[0][0]" comment="Enable NIFs to allow CHECKSUMs to be captured"/>
    <register addr="d00000e0" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_RX_STATUS[0][0][0]" comment="CHECKSUM for RX IQ monitor"/>
    <register addr="d00000e4" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_RX_STATUS[0][0][1]" comment="CHECKSUM for RX IQ monitor"/>
    <register addr="d00000e8" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_TX_STATUS[0][0][0]" comment="CHECKSUM for TX IQ monitor"/>
    <register addr="d00000ec" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_TX_STATUS[0][0][1]" comment="CHECKSUM for TX IQ monitor"/>
    <register addr="d00000f0" rw_flags="RW" width="2" name="WLAN_ABB_LH_PHY_CONFIG[0][0]" comment="Control bits for the ABB end of the longhop.."/>
    <register addr="d00000f4" rw_flags="RW" width="2" name="WLAN_ABB_LH_PHY2ABB_CONTROL[1][0]" comment="LongHop control for PHY2ABB."/>
    <register addr="d00000f8" rw_flags="R" width="2" name="WLAN_ABB_LH_PHY2ABB_STATUS[1][0]" comment="LongHop status for the PHY2ABB."/>
    <register addr="d00000fc" rw_flags="RW" width="2" name="WLAN_ABB_LH_ABB2PHY_CONTROL[1][0]" comment="LongHop control for ABB2PHY."/>
    <register addr="d0000100" rw_flags="R" width="2" name="WLAN_ABB_LH_ABB2PHY_STATUS[1][0]" comment="LongHop status for the ABB2PHY."/>
    <register addr="d0000104" rw_flags="RW" width="1" name="WLAN_ABB_LH_DEBUG_CONTROL[1][0]" comment="Enable NIFs to allow CHECKSUMs to be captured"/>
    <register addr="d0000108" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_RX_STATUS[1][0][0]" comment="CHECKSUM for RX IQ monitor"/>
    <register addr="d000010c" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_RX_STATUS[1][0][1]" comment="CHECKSUM for RX IQ monitor"/>
    <register addr="d0000110" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_TX_STATUS[1][0][0]" comment="CHECKSUM for TX IQ monitor"/>
    <register addr="d0000114" rw_flags="R" width="2" name="WLAN_ABB_LH_DEBUG_TX_STATUS[1][0][1]" comment="CHECKSUM for TX IQ monitor"/>
    <register addr="d0000118" rw_flags="RW" width="2" name="WLAN_ABB_LH_PHY_CONFIG[1][0]" comment="Control bits for the ABB end of the longhop.."/>
    <register addr="d000011c" rw_flags="RW" width="2" name="PCR_DRAM_EARLY_WAKEUP" comment="DRAM early wakeup counter setting. When this changes from zero to non-zero this triggers the logic to capture the new non-zero value."/>
    <register addr="d0000120" rw_flags="RW" width="1" name="PCR_FLEXI_PROC_POR_RESET" comment="FlexiMac processor power-on reset software control. This resets all of the M3 logic."/>
    <register addr="d0000124" rw_flags="RW" width="1" name="PCR_FLEXI_PROC_SYS_RESET" comment="FlexiMac processor sys reset control. This resets just the core logic, not the debug logic."/>
    <register addr="d0000128" rw_flags="RW" width="1" name="PCR_FLEXI_MTX_CLOCK_EN" comment="FlexiMac processor platform interconnect matrix clock enables. Also overrides the MAC and MAC_MEM clock enables in mac_clkgen."/>
    <register addr="d000012c" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[0]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000130" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[1]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000134" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[2]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000138" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[3]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d000013c" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[4]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000140" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[5]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000144" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[6]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d0000148" rw_flags="RW" width="4" name="PCR_SIM_MAILBOX[7]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d000014c" rw_flags="R" width="4" name="PCR_REGS_FAILED_ADDRESS" comment="Address of last register access that failed to complete successfully, usually resulting in a CPU abort of some sort."/>
    <register addr="d0000150" rw_flags="RW" width="1" name="PCR_REGS_STATUS" comment="Observe the register bus failure status. Write to a field to clear it."/>
    <register addr="d0000154" rw_flags="R" width="2" name="RANDOM_NUMBER" comment="Random number. Enable generation by setting CLOCK_ENABLE_40_RAND to '1'."/>
    <register addr="d0000158" rw_flags="RW" width="1" name="PCR_DEBUG_SEL" comment="Processor platform debug selection"/>
    <register addr="d000015c" rw_flags="RW" width="1" name="PCR_SEMAPHORE[0]" comment="Array of single bit semaphore registers."/>
    <register addr="d0000160" rw_flags="RW" width="1" name="PCR_SEMAPHORE[1]" comment="Array of single bit semaphore registers."/>
    <register addr="d0000164" rw_flags="RW" width="1" name="PCR_SEMAPHORE[2]" comment="Array of single bit semaphore registers."/>
    <register addr="d0000168" rw_flags="RW" width="1" name="PCR_SEMAPHORE[3]" comment="Array of single bit semaphore registers."/>
    <register addr="d000016c" rw_flags="RW" width="1" name="PCR_ETM_EXT_ENABLE_MASK" comment="Bitfield. Enable bit(s) to allow the ETM EXT bus from the R4 to propagate to the CoreSight block.."/>
    <register addr="d0000170" rw_flags="RW" width="2" name="PCR_IPC_OUT_CLEAR" comment="Inter-processor communication interrupt requests - Clear register bits/read register bits"/>
    <register addr="d0000174" rw_flags="RW" width="2" name="PCR_IPC_OUT_SET" comment="Inter-processor communication interrupt requests - Set register bits/read register bits"/>
    <register addr="d0000178" rw_flags="R" width="2" name="PCR_IPC_IN" comment="Inter-processor communication interrupt acknowledgements"/>
    <register addr="d000017c" rw_flags="RW" width="2" name="PCR_TOPW_LH_CONFIG" comment="Configuration for TOPW AXI LHASB source block."/>
    <register addr="d0000180" rw_flags="R" width="1" name="PCR_TOPW_LH_STATUS" comment="Configuration for TOPW AXI LHASB source block."/>
    <register addr="d0000184" rw_flags="RW" width="2" name="PCR_PERT_LH_CONFIG" comment="Configuration for PERT AXI LHASB source block."/>
    <register addr="d0000188" rw_flags="R" width="1" name="PCR_PERT_LH_STATUS" comment="Configuration for PERT AXI LHASB source block."/>
    <register addr="d000018c" rw_flags="RW" width="2" name="PCR_NIC_TO_FLEXP_LH_CONFIG" comment="Configuration for primary Fleximac to NIC-400 AXI LHASB destination block."/>
    <register addr="d0000190" rw_flags="R" width="1" name="PCR_NIC_TO_FLEXP_LH_STATUS" comment="Status for primary Fleximac to NIC-400 AXI LHASB destination block."/>
    <register addr="d0000194" rw_flags="RW" width="2" name="PCR_FLEXP_TO_NIC_LH_CONFIG" comment="Configuration for primary Fleximac to NIC-400 AXI LHASB destination block."/>
    <register addr="d0000198" rw_flags="R" width="1" name="PCR_FLEXP_TO_NIC_LH_STATUS" comment="Status for primary Fleximac to NIC-400 AXI LHASB destination block."/>
    <register addr="d000019c" rw_flags="RW" width="2" name="PCR_NIC_TO_RAMSP_LH_CONFIG" comment="Configuration for NIC-400 to primary RAMS AXI LHASB destination block."/>
    <register addr="d00001a0" rw_flags="R" width="1" name="PCR_NIC_TO_RAMSP_LH_STATUS" comment="Status for NIC-400 to primary RAMS AXI LHASB destination block."/>
    <register addr="d00001a4" rw_flags="RW" width="2" name="PCR_WLAUX_REGS_SRC_LH_CONFIG" comment="Configuration for PERI to WLAUX regs LHASB source block."/>
    <register addr="d00001a8" rw_flags="R" width="1" name="PCR_WLAUX_REGS_SRC_LH_STATUS" comment="Status for PERI to WLAUX regs AXI LHASB source block."/>
    <register addr="d00001ac" rw_flags="RW" width="2" name="PCR_WLAUX_REGS_DST_LH_CONFIG" comment="Configuration for PERI to WLAUX regs LHASB destination block - in BLK_WLAUX."/>
    <register addr="d00001b0" rw_flags="R" width="1" name="PCR_WLAUX_REGS_DST_LH_STATUS" comment="Status for PERI to WLAUX regs AXI LHASB destination block - in BLK_WLAUX."/>
    <register addr="d00001b4" rw_flags="RW" width="1" name="INTRA_WLAN_IPC_CLEAR" comment="IPC register going to all WLMACPHY instances, plus all UCPUs, as interrupt sources. Each bit is independently settable and clearable by writing 1 to the _SET or _CLEAR register in the appropriate bit position. - Clear register bits/read register bits"/>
    <register addr="d00001b8" rw_flags="RW" width="1" name="INTRA_WLAN_IPC_SET" comment="IPC register going to all WLMACPHY instances, plus all UCPUs, as interrupt sources. Each bit is independently settable and clearable by writing 1 to the _SET or _CLEAR register in the appropriate bit position. - Set register bits/read register bits"/>
    <register addr="d00001bc" rw_flags="RW" width="1" name="PCR_FLEXIMAC_POSTED_IPC_CLEAR" comment="Interrupt generator register for Fleximac posted writes. - Clear register bits/read register bits"/>
    <register addr="d00001c0" rw_flags="RW" width="1" name="PCR_FLEXIMAC_POSTED_IPC_SET" comment="Interrupt generator register for Fleximac posted writes. - Set register bits/read register bits"/>
  </block>
  <block name="pcr_ticker" comment="Processor basic timer">
    <register addr="d0100000" rw_flags="R" width="4" name="TCKR_VALUE" comment="Current value of the ticker"/>
    <register addr="d0100004" rw_flags="RW" width="4" name="TCKR_ALARM[0]" comment="Set the Proc alarm value. As a side effect - clears the corresponding interrupt line"/>
    <register addr="d0100008" rw_flags="RW" width="4" name="TCKR_ALARM[1]" comment="Set the Proc alarm value. As a side effect - clears the corresponding interrupt line"/>
    <register addr="d010000c" rw_flags="RW" width="4" name="TCKR_ALARM[2]" comment="Set the Proc alarm value. As a side effect - clears the corresponding interrupt line"/>
    <register addr="d0100010" rw_flags="RW" width="1" name="TCKR_CTRL[0]" comment="The Proc alarm control register"/>
    <register addr="d0100014" rw_flags="RW" width="1" name="TCKR_CTRL[1]" comment="The Proc alarm control register"/>
    <register addr="d0100018" rw_flags="RW" width="1" name="TCKR_CTRL[2]" comment="The Proc alarm control register"/>
  </block>
  <block name="topw_axi_monitor" comment="Monitor transactions on the AXI bus.">
    <register addr="d3000000" rw_flags="RW" width="1" name="TOPW_AXI_MON_ENABLE" comment="Enable the AXI monitor. Enabled by default because turning it on at any point would mean probably missing something and getting out of sync."/>
    <register addr="d3000004" rw_flags="RW" width="2" name="TOPW_AXI_MON_ID_WRITE_MASK" comment="Bitfield indicating from which AXI ID(s) bits to to check in burst transactions. If 0, all masters are monitored. If mask is non-zero then if a matching value in AXI_MON_ID_VALUE for the bits set here is true then monitoring occurs."/>
    <register addr="d3000008" rw_flags="RW" width="2" name="TOPW_AXI_MON_ID_WRITE_VALUE" comment="Value to match the incoming AXI ID against."/>
    <register addr="d300000c" rw_flags="RW" width="2" name="TOPW_AXI_MON_ID_READ_MASK" comment="Bitfield indicating from which AXI ID(s) bits to to check in burst transactions. If 0, all masters are monitored. If mask is non-zero then if a matching value in AXI_MON_ID_VALUE for the bits set here is true then monitoring occurs."/>
    <register addr="d3000010" rw_flags="RW" width="2" name="TOPW_AXI_MON_ID_READ_VALUE" comment="Value to match the incoming AXI ID against."/>
    <register addr="d3000014" rw_flags="R" width="4" name="TOPW_AXI_MON_INST_READ_BURST_COUNT" comment="Count of the number of read burst transactions on the AXI read channel."/>
    <register addr="d3000018" rw_flags="R" width="4" name="TOPW_AXI_MON_INST_READ_BYTE_COUNT" comment="Count of the number of bytes transferred in the read burst transactions on the AXI read channel."/>
    <register addr="d300001c" rw_flags="R" width="4" name="TOPW_AXI_MON_INST_WRITE_BURST_COUNT" comment="Count of the number of write burst transactions on the AXI read channel."/>
    <register addr="d3000020" rw_flags="R" width="4" name="TOPW_AXI_MON_INST_WRITE_BYTE_COUNT" comment="Count of the number of bytes transferred in the write burst transactions on the AXI write channel."/>
    <register addr="d3000024" rw_flags="R" width="4" name="TOPW_AXI_MON_DATA_READ_BURST_COUNT" comment="Count of the number of read burst transactions on the AXI read channel."/>
    <register addr="d3000028" rw_flags="R" width="4" name="TOPW_AXI_MON_DATA_READ_BYTE_COUNT" comment="Count of the number of bytes transferred in the read burst transactions on the AXI read channel."/>
    <register addr="d300002c" rw_flags="R" width="4" name="TOPW_AXI_MON_DATA_WRITE_BURST_COUNT" comment="Count of the number of write burst transactions on the AXI read channel."/>
    <register addr="d3000030" rw_flags="R" width="4" name="TOPW_AXI_MON_DATA_WRITE_BYTE_COUNT" comment="Count of the number of bytes transferred in the write burst transactions on the AXI write channel."/>
    <register addr="d3000034" rw_flags="R" width="4" name="TOPW_AXI_MON_OUTSTANDING_STATUS" comment="Dynamic status of outstanding reads/writes"/>
    <register addr="d3000038" rw_flags="R" width="4" name="TOPW_AXI_MON_OUTSTANDING_STATUS_MAX" comment="Maximum value of outstanding reads/writes since last clear."/>
    <register addr="d300003c" rw_flags="W" width="1" name="TOPW_AXI_MON_OUTSTANDING_STATUS_MAX_CLEAR" comment="Clear status of outstanding reads/writes"/>
  </block>
  <block name="ucpu_config_0" comment="UCPU power domain config/status registers.">
    <register addr="d1000000" rw_flags="RW" width="4" name="UCPU_PIO_DRIVE_I0" comment="PIO output values for PIO[16:0]"/>
    <register addr="d1000004" rw_flags="RW" width="4" name="UCPU_PIO_DRIVE_EN_I0" comment="PIO output enable for PIO[16:0]"/>
    <register addr="d1000008" rw_flags="R" width="4" name="UCPU_PIO_STATUS_I0" comment="PIO status values for PIO[16:0]"/>
    <register addr="d100000c" rw_flags="RW" width="4" name="UCPU_QOS_I0" comment="Quality of service values for the NIC-400 AXI masters."/>
    <register addr="d1000010" rw_flags="RW" width="1" name="UCPU_RMP_RGN0_BOOT_I0" comment="R7 Boot Address Remapping Region 0 Enable"/>
    <register addr="d1000014" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[0]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d1000018" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[1]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d100001c" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[2]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d1000020" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[3]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d1000024" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[4]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d1000028" rw_flags="RW" width="4" name="UCPU_RMP_RGN_BASE_I0[5]" comment="R7 Address Remapping Region N Start Address (4K address)"/>
    <register addr="d100002c" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[0]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d1000030" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[1]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d1000034" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[2]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d1000038" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[3]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d100003c" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[4]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d1000040" rw_flags="RW" width="1" name="UCPU_RMP_RGN_SIZE_I0[5]" comment="R7 Address Remapping Region N Size (multiples of 4K bytes)"/>
    <register addr="d1000044" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[0]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d1000048" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[1]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d100004c" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[2]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d1000050" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[3]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d1000054" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[4]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d1000058" rw_flags="RW" width="4" name="UCPU_RMP_RGN_OFST_I0[5]" comment="R7 Address Remapping Region N Offset (4K bytes)"/>
    <register addr="d100005c" rw_flags="RW" width="1" name="UCPU_AXI_LPI_CONFIG_I0" comment="AXI LPI block configuration. Set to 1 for clocking reduction."/>
    <register addr="d1000060" rw_flags="RW" width="2" name="UCPU_DRAM_EARLY_WAKEUP_I0" comment="DRAM early wakeup counter setting. When this changes from zero to non-zero this triggers the logic to capture the new non-zero value."/>
    <register addr="d1000064" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[0]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000068" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[1]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d100006c" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[2]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000070" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[3]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000074" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[4]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000078" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[5]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d100007c" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[6]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000080" rw_flags="RW" width="4" name="UCPU_SIM_MAILBOX_I0[7]" comment="Handy registers to make simulation testing much easier. Can be directly used in FPGAs for debug."/>
    <register addr="d1000084" rw_flags="RW" width="1" name="UCPU_ETM_RESET_I0" comment="Set to 1 to reset the ETM number associated with the core."/>
    <register addr="d1000088" rw_flags="RW" width="1" name="UCPU_ETM_EXT_ENABLE_MASK_I0" comment="Bitfield. Enable bit(s) to allow the ETM EXT bus from the R4 to propagate to the CoreSight block.."/>
    <register addr="d100008c" rw_flags="RW" width="1" name="UCPU_CT_RESET_I0" comment="Set to 1 to reset the Cross-trigger interface. This also controls the integration layer debug."/>
    <register addr="d1000090" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][0]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d1000094" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][1]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d1000098" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][2]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d100009c" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][3]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000a0" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][4]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000a4" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[0][5]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000a8" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][0]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000ac" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][1]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000b0" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][2]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000b4" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][3]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000b8" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][4]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000bc" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[0][5]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000c0" rw_flags="RW" width="1" name="UCPU_XDMA_ADDR_CHECK_EN_I0[0]" comment="Set a bit to 1 to enable the corresponding address check region."/>
    <register addr="d10000c4" rw_flags="R" width="1" name="UCPU_XDMA_ADDR_CHECK_AR_INT_STATUS_I0[0]" comment="Interrupt status of read address AXI channel."/>
    <register addr="d10000c8" rw_flags="W" width="1" name="UCPU_XDMA_ADDR_CHECK_AR_INT_CLEAR_I0[0]" comment="Write a 1 to clear the interrupt status."/>
    <register addr="d10000cc" rw_flags="R" width="4" name="UCPU_XDMA_ADDR_CHECK_AR_ERROR_ADDR_I0[0]" comment="The address which caused the error."/>
    <register addr="d10000d0" rw_flags="R" width="1" name="UCPU_XDMA_ADDR_CHECK_AW_INT_STATUS_I0[0]" comment="Interrupt status of write address AXI channel."/>
    <register addr="d10000d4" rw_flags="W" width="1" name="UCPU_XDMA_ADDR_CHECK_AW_INT_CLEAR_I0[0]" comment="Write a 1 to clear the interrupt status."/>
    <register addr="d10000d8" rw_flags="R" width="4" name="UCPU_XDMA_ADDR_CHECK_AW_ERROR_ADDR_I0[0]" comment="The address which caused the error."/>
    <register addr="d10000dc" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][0]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000e0" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][1]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000e4" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][2]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000e8" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][3]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000ec" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][4]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000f0" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_START_I0[1][5]" comment="Start 4k page number for address checking. The logic checks for the address being greater than or equal to this number."/>
    <register addr="d10000f4" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][0]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000f8" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][1]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d10000fc" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][2]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d1000100" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][3]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d1000104" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][4]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d1000108" rw_flags="RW" width="4" name="UCPU_XDMA_ADDR_CHECK_END_I0[1][5]" comment="End 4k page number for address checking. The logic checks for the address being lower than this number."/>
    <register addr="d100010c" rw_flags="RW" width="1" name="UCPU_XDMA_ADDR_CHECK_EN_I0[1]" comment="Set a bit to 1 to enable the corresponding address check region."/>
    <register addr="d1000110" rw_flags="R" width="1" name="UCPU_XDMA_ADDR_CHECK_AR_INT_STATUS_I0[1]" comment="Interrupt status of read address AXI channel."/>
    <register addr="d1000114" rw_flags="W" width="1" name="UCPU_XDMA_ADDR_CHECK_AR_INT_CLEAR_I0[1]" comment="Write a 1 to clear the interrupt status."/>
    <register addr="d1000118" rw_flags="R" width="4" name="UCPU_XDMA_ADDR_CHECK_AR_ERROR_ADDR_I0[1]" comment="The address which caused the error."/>
    <register addr="d100011c" rw_flags="R" width="1" name="UCPU_XDMA_ADDR_CHECK_AW_INT_STATUS_I0[1]" comment="Interrupt status of write address AXI channel."/>
    <register addr="d1000120" rw_flags="W" width="1" name="UCPU_XDMA_ADDR_CHECK_AW_INT_CLEAR_I0[1]" comment="Write a 1 to clear the interrupt status."/>
    <register addr="d1000124" rw_flags="R" width="4" name="UCPU_XDMA_ADDR_CHECK_AW_ERROR_ADDR_I0[1]" comment="The address which caused the error."/>
    <register addr="d1000128" rw_flags="RW" width="1" name="UCPU_XDMA_L1_COHERENCY_I0" comment="Coherency settings for XDMA access through the R7 ACP port.&amp;lt;br&amp;gt; The coherency between the ACP traffic and the L1 data cache of the processors is triggered when AxUSER[0] = 1 and AxCACHE[1] = 1:&amp;lt;br&amp;gt; * AxUSER[0] is the shared bit.&amp;lt;br&amp;gt; * AxCACHE[1] = 1 indicates it is a NC, WT, WB, or a WBWA memory region.&amp;lt;br&amp;gt; * AxCACHE[1] = 0 indicates it is a SO, or DV memory region. Using the AxCACHE[1]&amp;lt;br&amp;gt; bit prevents SO and DV memory regions from taking part in the coherency mechanism,&amp;lt;br&amp;gt; that is, SCU lookups, on the ACP.&amp;lt;br&amp;gt; x represents either R for read or W for write"/>
    <register addr="d100012c" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_DCACHE_I0[0]" comment="Config for allowing auto-retention of DCACHE."/>
    <register addr="d1000130" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_ICACHE_I0[0]" comment="Config for allowing auto-retention of ICACHE."/>
    <register addr="d1000134" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_DTCM_I0[0]" comment="Config for allowing auto-retention of DTCM."/>
    <register addr="d1000138" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_ITCM_I0[0]" comment="Config for allowing auto-retention of ITCM."/>
    <register addr="d100013c" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_DCACHE_I0[1]" comment="Config for allowing auto-retention of DCACHE."/>
    <register addr="d1000140" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_ICACHE_I0[1]" comment="Config for allowing auto-retention of ICACHE."/>
    <register addr="d1000144" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_DTCM_I0[1]" comment="Config for allowing auto-retention of DTCM."/>
    <register addr="d1000148" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_ITCM_I0[1]" comment="Config for allowing auto-retention of ITCM."/>
    <register addr="d100014c" rw_flags="RW" width="4" name="CORTEX_RAM_RETENTION_CONFIG_SCU_I0" comment="Config for allowing auto-retention of SCU."/>
    <register addr="d1000150" rw_flags="RW" width="1" name="UCPU_XDMA_IRQ_DEST_MASK_I0[0]" comment="Bitfields of destination CPUs for the XDMA interrupt. 1 = Enabled."/>
    <register addr="d1000154" rw_flags="RW" width="1" name="UCPU_XDMA_IRQ_DEST_MASK_I0[1]" comment="Bitfields of destination CPUs for the XDMA interrupt. 1 = Enabled."/>
  </block>
  <block name="wlaux" comment="WLAUX registers.">
    <register addr="d2000000" rw_flags="RW" width="1" name="WLAUX_BFEE_CONTROL" comment="Control to the BFEE block."/>
    <register addr="d2000004" rw_flags="R" width="4" name="WLAUX_BFEE_STATUS" comment="BFEE core status"/>
    <register addr="d2000008" rw_flags="R" width="4" name="WLAUX_BFEE_DEBUG" comment="Control to the BFEE block."/>
    <register addr="d200000c" rw_flags="RW" width="1" name="WLAUX_BFEE_SEMAPHORE" comment="Semaphore to control access to the BFEE block."/>
    <register addr="d2000010" rw_flags="RW" width="2" name="WLAUX_CONTROL_LH_PHY2BFEE[0]" comment="Configuration for PHY2BFEE ATB longhops."/>
    <register addr="d2000014" rw_flags="R" width="1" name="WLAUX_STATUS_LH_PHY2BFEE[0]" comment="Status for PHY2BFEE input ATB longhops."/>
    <register addr="d2000018" rw_flags="RW" width="2" name="WLAUX_CONTROL_LH_BFEE2PHY[0]" comment="Configuration for BFEE2PHY output ATB longhops."/>
    <register addr="d200001c" rw_flags="R" width="1" name="WLAUX_STATUS_LH_BFEE2PHY[0]" comment="Status for BFEE2PHY output ATB longhops."/>
  </block>
  <block name="xdmac_00" comment="XDMAC registers - derived from http://cognidox/vdocs/SC-507020-DD-A-XDMA%20Register%20Map.pdf. Not instanced in the RTL.">
    <register addr="d120000c" rw_flags="R" width="1" name="XDMAC_INT_TC_STATUS_I00" comment="Transfer Complete Interrupt Status Register."/>
    <register addr="d1200010" rw_flags="W" width="1" name="XDMAC_INT_TC_CLR_I00" comment="Transfer Complete Interrupt Clear Register (Value is not meaningful)"/>
    <register addr="d1200014" rw_flags="RW" width="1" name="XDMAC_INT_TC_MASK_I00" comment="Transfer Complete Interrupt Mask Register (0: Interrupt disabled, 1 : Interrupt enabled)"/>
    <register addr="d1200018" rw_flags="R" width="1" name="XDMAC_ERR_STATUS_I00" comment="Error Interrupt Status Register"/>
    <register addr="d120001c" rw_flags="W" width="1" name="XDMAC_INT_ERR_CLR_I00" comment="Error Interrupt Clear Register"/>
    <register addr="d1200020" rw_flags="RW" width="1" name="XDMAC_INT_ERR_MASK_I00" comment="Error Interrupt Mask Register (0: Interrupt disabled, 1 : Interrupt enabled)"/>
    <register addr="d1200024" rw_flags="W" width="1" name="XDMAC_START_I00" comment="DMA Transfer Start (Value is not meaningful). Do NOT start DMA again until the previously started DMA transfer is completed."/>
    <register addr="d1200028" rw_flags="RW" width="1" name="XDMAC_ICG_DISABLE_I00" comment="Internal clock gating is disabled (0 : Clock gating enabled, 1 : Clock gating disabled)"/>
    <register addr="d120002c" rw_flags="RW" width="4" name="XDMAC_CONFIG_I00" comment="Configuration Register"/>
    <register addr="d1200030" rw_flags="RW" width="4" name="XDMAC_LLI_SRC_ADDR_I00" comment="Source Address Register (Linked List Item)"/>
    <register addr="d1200034" rw_flags="RW" width="4" name="XDMAC_LLI_DST_ADDR_I00" comment="Destination Address Register (Linked List Item)"/>
    <register addr="d1200038" rw_flags="RW" width="4" name="XDMAC_LLI_NXT_ADDR_I00" comment="Next Address Register to indicate the next linked list item (Linked List Item)"/>
    <register addr="d120003c" rw_flags="RW" width="4" name="XDMAC_LLI_CTRL_I00" comment=""/>
    <register addr="d1200040" rw_flags="R" width="1" name="XDMAC_DMA_STATUS_I00" comment="DMA active status. 1 = active. 0 = idle"/>
    <register addr="d1200044" rw_flags="R" width="1" name="XDMAC_DMA_COUNT_I00" comment="Number of DMA list entries processed for the current operation."/>
  </block>
  <block name="xdmac_01" comment="XDMAC registers - derived from http://cognidox/vdocs/SC-507020-DD-A-XDMA%20Register%20Map.pdf. Not instanced in the RTL.">
    <register addr="d130000c" rw_flags="R" width="1" name="XDMAC_INT_TC_STATUS_I01" comment="Transfer Complete Interrupt Status Register."/>
    <register addr="d1300010" rw_flags="W" width="1" name="XDMAC_INT_TC_CLR_I01" comment="Transfer Complete Interrupt Clear Register (Value is not meaningful)"/>
    <register addr="d1300014" rw_flags="RW" width="1" name="XDMAC_INT_TC_MASK_I01" comment="Transfer Complete Interrupt Mask Register (0: Interrupt disabled, 1 : Interrupt enabled)"/>
    <register addr="d1300018" rw_flags="R" width="1" name="XDMAC_ERR_STATUS_I01" comment="Error Interrupt Status Register"/>
    <register addr="d130001c" rw_flags="W" width="1" name="XDMAC_INT_ERR_CLR_I01" comment="Error Interrupt Clear Register"/>
    <register addr="d1300020" rw_flags="RW" width="1" name="XDMAC_INT_ERR_MASK_I01" comment="Error Interrupt Mask Register (0: Interrupt disabled, 1 : Interrupt enabled)"/>
    <register addr="d1300024" rw_flags="W" width="1" name="XDMAC_START_I01" comment="DMA Transfer Start (Value is not meaningful). Do NOT start DMA again until the previously started DMA transfer is completed."/>
    <register addr="d1300028" rw_flags="RW" width="1" name="XDMAC_ICG_DISABLE_I01" comment="Internal clock gating is disabled (0 : Clock gating enabled, 1 : Clock gating disabled)"/>
    <register addr="d130002c" rw_flags="RW" width="4" name="XDMAC_CONFIG_I01" comment="Configuration Register"/>
    <register addr="d1300030" rw_flags="RW" width="4" name="XDMAC_LLI_SRC_ADDR_I01" comment="Source Address Register (Linked List Item)"/>
    <register addr="d1300034" rw_flags="RW" width="4" name="XDMAC_LLI_DST_ADDR_I01" comment="Destination Address Register (Linked List Item)"/>
    <register addr="d1300038" rw_flags="RW" width="4" name="XDMAC_LLI_NXT_ADDR_I01" comment="Next Address Register to indicate the next linked list item (Linked List Item)"/>
    <register addr="d130003c" rw_flags="RW" width="4" name="XDMAC_LLI_CTRL_I01" comment=""/>
    <register addr="d1300040" rw_flags="R" width="1" name="XDMAC_DMA_STATUS_I01" comment="DMA active status. 1 = active. 0 = idle"/>
    <register addr="d1300044" rw_flags="R" width="1" name="XDMAC_DMA_COUNT_I01" comment="Number of DMA list entries processed for the current operation."/>
  </block>
</subsystem>
